<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>로그 다듬기</title>
<style>
:root{
  --bg:#fbfbf9;
  --paper:#ffffff;
  --ink:#17181c;
  --sub:#5a5f6b;
  --line:#e7e7e2;
  --accent:#3b5bfd;
  --radius:18px;
}
*{box-sizing:border-box;}
body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans KR",sans-serif;
}
.wrap{
  max-width:1100px;
  margin:40px auto;
  padding:0 20px;
}
h1{
  margin:0 0 8px 0;
  font-size:22px;
}
.sub{
  color:var(--sub);
  font-size:13px;
  margin-bottom:20px;
}
.card{
  background:var(--paper);
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:18px;
}
.toolbar{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  margin-bottom:18px;
  align-items:center;
}
label{
  font-size:13px;
  color:var(--sub);
}
select{
  padding:6px 8px;
  border-radius:10px;
  border:1px solid var(--line);
}
button{
  padding:8px 12px;
  border-radius:10px;
  border:1px solid var(--line);
  background:#fff;
  cursor:pointer;
}
button:hover{
  background:#f4f4f2;
}
.grid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:16px;
}
textarea{
  width:100%;
  height:420px;
  border:1px solid var(--line);
  border-radius:14px;
  padding:12px;
  resize:none;
  font-size:14px;
  line-height:1.7;
}
textarea[readonly]{
  background:#fafaf8;
}
@media(max-width:900px){
  .grid{grid-template-columns:1fr;}
}
</style>
</head>
<body>
<div class="wrap">
  <h1>✍️ 로그 다듬기</h1>
  <div class="sub">지문(*) 처리 · 대사 따옴표 · details 제거 · 빈 줄 정리</div>

  <div class="card">
    <div class="toolbar">
      <label><input type="checkbox" id="removeDetails"> &lt;details&gt; 제거</label>
      <label><input type="checkbox" id="removeEmptyLines"> 문단 빈 줄 제거</label>
      <label>
        따옴표
        <select id="quoteStyle">
          <option value="none">넣지 않음</option>
          <option value="straight">" "</option>
          <option value="doubleCurly" selected>“ ”</option>
          <option value="singleCurly">‘ ’</option>
        </select>
      </label>
      <button onclick="copyResult()">결과 복사</button>
      <button onclick="downloadTxt()">TXT 다운로드</button>
      <button onclick="clearAll()">초기화</button>
    </div>

    <div class="grid">
      <textarea id="inputText" placeholder="여기에 로그를 붙여 넣으세요"></textarea>
      <textarea id="outputText" readonly placeholder="변환 결과"></textarea>
    </div>
  </div>
</div>

<script>
const input = document.getElementById("inputText");
const output = document.getElementById("outputText");

input.addEventListener("input", transformText);
document.getElementById("quoteStyle").addEventListener("change", transformText);
document.getElementById("removeDetails").addEventListener("change", transformText);
document.getElementById("removeEmptyLines").addEventListener("change", transformText);

// 핵심: *...* 블록을 "지문 문단"으로 항상 분리 + 나머지는 빈 줄 기준 문단
function parseChunks(text){
  const s = (text || "").replace(/\r/g, "");
  const out = [];

  let i = 0;
  let normalBuf = "";

  const flushNormal = () => {
    if (!normalBuf) return;
    const parts = normalBuf
      .split(/\n\s*\n+/)
      .map(p => p.trim())
      .filter(Boolean);

    for (const p of parts) out.push({ kind: "normal", text: p });
    normalBuf = "";
  };

  while (i < s.length){
    if (s[i] !== "*"){
      normalBuf += s[i];
      i++;
      continue;
    }

    // 별표 지문 시작
    flushNormal();
    i++; // consume starting *

    let content = "";
    while (i < s.length && s[i] !== "*"){
      content += s[i];
      i++;
    }

    // 닫는 *가 있으면 소비, 없으면 파일 끝(그래도 지문)
    if (i < s.length && s[i] === "*") i++;

    out.push({ kind: "scene", text: content.trim() });

    // 지문 뒤 공백/개행은 문단 경계로 취급 (붙은 **, 엔터 1번 등도 처리)
    while (i < s.length && (s[i] === " " || s[i] === "\t" || s[i] === "\n")){
      // 다음이 '*'면 바로 다음 지문으로 이어질 수 있게 끊기
      i++;
      if (i < s.length && s[i] === "*") break;
    }
  }

  flushNormal();
  return out;
}

function getQuotes(style){
  if(style === "straight") return ['"', '"'];
  if(style === "doubleCurly") return ['“', '”'];
  if(style === "singleCurly") return ['‘', '’'];
  return ["", ""];
}

function isAlreadyQuoted(t){
  const pairs = [['"', '"'], ['“','”'], ['‘','’']];
  return pairs.some(([o,c]) => t.startsWith(o) && t.endsWith(c) && t.length >= 2);
}

function transformText(){
  let text = input.value || "";

  if(document.getElementById("removeDetails").checked){
    // 1) <details> ... </details> 통째 제거
    text = text.replace(/<details\b[\s\S]*?<\/details>/gi,"");
    // 2) 단독 <details> / </details> 줄 제거
    text = text.replace(/^\s*<\/?details.*?>\s*$/gim,"");
    // 3) <summary> ... </summary> 제거
    text = text.replace(/<summary.*?>.*?<\/summary>/gi,"");
  }

  const chunks = parseChunks(text);

  const quoteStyle = document.getElementById("quoteStyle").value;
  const [openQ, closeQ] = getQuotes(quoteStyle);

  const result = chunks.map(({kind, text: raw}) => {
    const t = (raw || "").trim();
    if(!t) return "";

    // ✅ 지문은 따옴표 금지 (별표는 파서에서 이미 제거됨)
    if(kind === "scene"){
  if(document.getElementById("removeEmptyLines").checked){
    // scene 내부의 빈 줄도 제거 (두 줄 이상 → 한 줄)
    return t.replace(/\n\s*\n+/g, "\n");
  }
  return t;
}


    // 따옴표 옵션이 none이면 그대로
    if(quoteStyle === "none") return t;

    // 이미 따옴표면 유지
    if(isAlreadyQuoted(t)) return t;

    return openQ + t + closeQ;
  }).filter(Boolean);

  const joiner = document.getElementById("removeEmptyLines").checked ? "\n" : "\n\n";
  output.value = result.join(joiner).trim();
}

// 아래 3개 함수는 버튼이 있을 때만 쓰면 됨
function copyResult(){
  navigator.clipboard.writeText(output.value);
  alert("복사되었습니다.");
}

function downloadTxt(){
  const blob = new Blob([output.value],{type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download="cleaned_log.txt";
  a.click();
  URL.revokeObjectURL(url);
}

function clearAll(){
  input.value="";
  output.value="";
}

</script>
</body>
</html>
