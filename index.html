<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>로그 다듬기</title>
<style>
:root{
  --bg:#fbfbf9;
  --paper:#ffffff;
  --ink:#17181c;
  --sub:#5a5f6b;
  --line:#e7e7e2;
  --accent:#3b5bfd;
  --radius:18px;
}
*{box-sizing:border-box;}
body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans KR",sans-serif;
}
.wrap{
  max-width:1100px;
  margin:40px auto;
  padding:0 20px;
}
h1{
  margin:0 0 8px 0;
  font-size:22px;
}
.sub{
  color:var(--sub);
  font-size:13px;
  margin-bottom:20px;
}
.card{
  background:var(--paper);
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:18px;
}
.toolbar{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  margin-bottom:18px;
  align-items:center;
}
label{
  font-size:13px;
  color:var(--sub);
}
select{
  padding:6px 8px;
  border-radius:10px;
  border:1px solid var(--line);
}
button{
  padding:8px 12px;
  border-radius:10px;
  border:1px solid var(--line);
  background:#fff;
  cursor:pointer;
}
button:hover{
  background:#f4f4f2;
}
.grid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:16px;
}
textarea{
  width:100%;
  height:420px;
  border:1px solid var(--line);
  border-radius:14px;
  padding:12px;
  resize:none;
  font-size:14px;
  line-height:1.7;
}
textarea[readonly]{
  background:#fafaf8;
}
@media(max-width:900px){
  .grid{grid-template-columns:1fr;}
}
</style>
</head>
<body>
<div class="wrap">
  <h1>✍️ 로그 다듬기</h1>
  <div class="sub">지문(*) 처리 · 대사 따옴표 · details 제거 · 빈 줄 정리</div>

  <div class="card">
    <div class="toolbar">
      <label><input type="checkbox" id="removeDetails"> &lt;details&gt; 제거</label>
      <label><input type="checkbox" id="removeEmptyLines"> 문단 빈 줄 제거</label>
      <label>
        따옴표
        <select id="quoteStyle">
          <option value="none">넣지 않음</option>
          <option value="straight">" "</option>
          <option value="doubleCurly" selected>“ ”</option>
          <option value="singleCurly">‘ ’</option>
        </select>
      </label>
      <button onclick="copyResult()">결과 복사</button>
      <button onclick="downloadTxt()">TXT 다운로드</button>
      <button onclick="clearAll()">초기화</button>
    </div>

    <div class="grid">
      <textarea id="inputText" placeholder="여기에 로그를 붙여 넣으세요"></textarea>
      <textarea id="outputText" readonly placeholder="변환 결과"></textarea>
    </div>
  </div>
</div>

<script>
const input = document.getElementById("inputText");
const output = document.getElementById("outputText");

input.addEventListener("input", transformText);
document.getElementById("quoteStyle").addEventListener("change", transformText);
document.getElementById("removeDetails").addEventListener("change", transformText);
document.getElementById("removeEmptyLines").addEventListener("change", transformText);

function parseParagraphsWithStarBlocks(text){
  // 목표:
  // - * ... * 는 무조건 "지문 문단 1개"로 분리 (안에 줄바꿈/빈줄 있어도 OK)
  // - *...**...* 처럼 붙어 있어도 각각 분리
  // - *...*\n*...* 처럼 엔터 한 번만 있어도 각각 분리
  // - *로 시작했는데 끝 * 없이 파일 끝나도 지문으로 취급 (문단 1개)
  // - 나머지(대사/일반)는 빈 줄 기준으로 문단 분리

  const s = (text || "").replace(/\r/g, "");
  const out = [];

  let i = 0;
  let normalBuf = "";

  const flushNormal = () => {
    if (!normalBuf) return;
    // 일반 텍스트는 "빈 줄" 기준으로 문단 분리
    const parts = normalBuf.split(/\n\s*\n+/).map(p => p.trim()).filter(Boolean);
    out.push(...parts);
    normalBuf = "";
  };

  while (i < s.length){
    const ch = s[i];

    if (ch !== "*"){
      normalBuf += ch;
      i++;
      continue;
    }

    // 여기부터 별표 블록 시작
    flushNormal(); // 별표 블록 앞의 일반 텍스트 문단 확정

    i++; // 시작 '*' 소비
    let starContent = "";

    // 다음 '*'가 나올 때까지(또는 끝까지) 내용을 모은다
    while (i < s.length && s[i] !== "*"){
      starContent += s[i];
      i++;
    }

    if (i < s.length && s[i] === "*"){
      // 정상적으로 닫힘: 닫는 '*' 소비
      i++;
      out.push(starContent.trim());
    } else {
      // 끝 '*' 없이 파일 종료: 그래도 지문 문단으로 취급
      out.push(starContent.trim());
      break;
    }

    // 별표 블록 직후에 붙어있는 개행/공백이 있어도
    // "다음 별표 블록"과 섞이지 않도록,
    // 일반 버퍼로 넣지 않고 그냥 건너뛴다(문단 경계로 취급).
    while (i < s.length && (s[i] === " " || s[i] === "\t" || s[i] === "\n")){
      // 단, 일반 텍스트가 바로 이어지는 경우를 위해
      // 개행은 정상 흐름에서 normalBuf로 들어가도 되지만,
      // 여기서는 문단 경계를 유지하는 게 목적이라 일단 스킵.
      i++;
      // 다음이 '*'면 즉시 다음 별표 블록으로 이어짐(붙거나 엔터 1번이어도 OK)
      if (i < s.length && s[i] === "*") break;
    }
  }

  flushNormal();
  return out;
}


  for (let i = 0; i < lines.length; i++){
    const line = lines[i];
    const trimmed = line.trim();

    const isBlankLine = trimmed === "";

    // 별표 블록 시작 조건:
    // - 현재 문단(buf)이 비어 있고
    // - 줄이 '*'로 시작하면 (앞 공백 허용)
    if (!inStarBlock && buf.length === 0 && trimmed.startsWith("*")){
      inStarBlock = true;
    }

    if (!inStarBlock){
      // 일반 상태: 빈 줄이면 문단 끊기
      if (isBlankLine){
        flush();
        continue;
      }
      buf.push(line);
    } else {
      // 별표 블록 안: 빈 줄도 그대로 유지 (문단 끊지 않음)
      buf.push(line);

      // 별표 블록 종료 조건: 현재 줄이 '*'로 끝나면
      if (trimmed.endsWith("*") && trimmed.length >= 2){
        inStarBlock = false;
      }
    }
  }

  flush();
  return paras;
}

function transformText(){
  let text = input.value;

  if(document.getElementById("removeDetails").checked){

    // 1. <details> ... </details> 블록 통째 제거
    text = text.replace(/<details\b[\s\S]*?<\/details>/gi,"");

    // 2. 단독 <details> 또는 </details> 제거
    text = text.replace(/^\s*<\/?details.*?>\s*$/gim,"");

    // 3. <summary> ... </summary> 제거
    text = text.replace(/<summary.*?>.*?<\/summary>/gi,"");
  }

  let paragraphs = parseParagraphsWithStarBlocks(text);


  let quoteStyle = document.getElementById("quoteStyle").value;
  let openQuote="", closeQuote="";

  if(quoteStyle==="straight"){openQuote='"';closeQuote='"';}
  else if(quoteStyle==="doubleCurly"){openQuote='“';closeQuote='”';}
  else if(quoteStyle==="singleCurly"){openQuote='‘';closeQuote='’';}

  let result = paragraphs.map(p=>{
    let t = p.trim();
    if(!t) return "";

    // *지문* 처리
    // 지문 처리: 1) *...*  2) *로 시작했는데 끝 * 없이 끝난 경우
if (t.startsWith("*")) {
  // *...* 형태면 양끝 별 제거
  if (t.endsWith("*") && t.length >= 2) return t.slice(1, -1).trim();
  // *로 시작만 하고 끝별 없이 끝나면 앞의 *만 제거 (지문으로 취급)
  return t.slice(1).trim();
}


    if(quoteStyle==="none") return t;

    if(
      (t.startsWith('"') && t.endsWith('"')) ||
      (t.startsWith('“') && t.endsWith('”')) ||
      (t.startsWith('‘') && t.endsWith('’'))
    ){
      return t;
    }

    return openQuote + t + closeQuote;
  });

  let joiner = document.getElementById("removeEmptyLines").checked ? "\n" : "\n\n";
  output.value = result.filter(Boolean).join(joiner).trim();
}

function copyResult(){
  navigator.clipboard.writeText(output.value);
  alert("복사되었습니다.");
}

function downloadTxt(){
  const blob = new Blob([output.value],{type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download="cleaned_log.txt";
  a.click();
  URL.revokeObjectURL(url);
}

function clearAll(){
  input.value="";
  output.value="";
}
</script>
</body>
</html>
